"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.orientationMatch = void 0;

var _utils = require("../utils");

var _const = require("../const");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

// Helper: find the lowest rank possible
var getRankLimit = function getRankLimit(orientationRank) {
  var rankLimit = Object.values(orientationRank).reduce(function (rankValue, rankObj) {
    return Math.max.apply(Math, [rankValue].concat(_toConsumableArray(Object.values(rankObj))));
  }, 1);
  return rankLimit;
}; // Memoize the RANK_LIMIT from static const ORIENTATION_RANK


var RANK_LIMIT = getRankLimit(_const.ORIENTATION_RANK); // Distance of orientation rank between target and compare.

var orientationMatch = function orientationMatch(targetWidth, targetHeight, compareWidth, compareHeight, options) {
  var _ref = options || {},
      _ref$orientationLabel = _ref.orientationLabels,
      orientationLabels = _ref$orientationLabel === void 0 ? undefined : _ref$orientationLabel,
      _ref$orientationRank = _ref.orientationRank,
      orientationRank = _ref$orientationRank === void 0 ? undefined : _ref$orientationRank,
      _ref$sqRatioAccuracy = _ref.sqRatioAccuracy,
      sqRatioAccuracy = _ref$sqRatioAccuracy === void 0 ? undefined : _ref$sqRatioAccuracy;

  var rankLookup;
  var rankLimit;

  if (typeof orientationRank === 'undefined') {
    rankLookup = _const.ORIENTATION_RANK;
    rankLimit = RANK_LIMIT;
  } else {
    rankLookup = orientationRank;
    rankLimit = getRankLimit(orientationRank);
  } // Get orientation keys for ranking lookup (options pass through)


  var passThroughOptions = {
    sqRatioAccuracy: sqRatioAccuracy,
    orientationLabels: orientationLabels
  };
  var targetOrientation = (0, _utils.getOrientation)(targetWidth, targetHeight, passThroughOptions);
  var compareOrientation = (0, _utils.getOrientation)(compareWidth, compareHeight, passThroughOptions); // Get the ranking index value from orientation-to-orientation lookup

  var compareRank = rankLookup[targetOrientation][compareOrientation]; // Find the percentage for compare rank from 1 (best) to worst (rank limit)

  var orientationMatch = (0, _utils.distanceInRange)(1, compareRank, rankLimit);
  return orientationMatch;
};

exports.orientationMatch = orientationMatch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXRjaGVycy9vcmllbnRhdGlvbi50cyJdLCJuYW1lcyI6WyJnZXRSYW5rTGltaXQiLCJvcmllbnRhdGlvblJhbmsiLCJyYW5rTGltaXQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJyYW5rVmFsdWUiLCJyYW5rT2JqIiwiTWF0aCIsIm1heCIsIlJBTktfTElNSVQiLCJPUklFTlRBVElPTl9SQU5LIiwib3JpZW50YXRpb25NYXRjaCIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwiY29tcGFyZVdpZHRoIiwiY29tcGFyZUhlaWdodCIsIm9wdGlvbnMiLCJvcmllbnRhdGlvbkxhYmVscyIsInVuZGVmaW5lZCIsInNxUmF0aW9BY2N1cmFjeSIsInJhbmtMb29rdXAiLCJwYXNzVGhyb3VnaE9wdGlvbnMiLCJ0YXJnZXRPcmllbnRhdGlvbiIsImNvbXBhcmVPcmllbnRhdGlvbiIsImNvbXBhcmVSYW5rIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUE7O0FBQ0E7Ozs7Ozs7Ozs7QUFFQTtBQUNBLElBQU1BLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUNDLGVBQUQsRUFBa0Q7QUFDckUsTUFBTUMsU0FBUyxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0gsZUFBZCxFQUErQkksTUFBL0IsQ0FBc0MsVUFBQ0MsU0FBRCxFQUFZQyxPQUFaLEVBQXdCO0FBQzlFLFdBQU9DLElBQUksQ0FBQ0MsR0FBTCxPQUFBRCxJQUFJLEdBQUtGLFNBQUwsNEJBQW1CSCxNQUFNLENBQUNDLE1BQVAsQ0FBY0csT0FBZCxDQUFuQixHQUFYO0FBQ0QsR0FGaUIsRUFFZixDQUZlLENBQWxCO0FBR0EsU0FBT0wsU0FBUDtBQUNELENBTEQsQyxDQU9BOzs7QUFDQSxJQUFNUSxVQUFVLEdBQUdWLFlBQVksQ0FBQ1csdUJBQUQsQ0FBL0IsQyxDQUVBOztBQUNPLElBQU1DLGdCQUFnQixHQUFHLDBCQUM5QkMsV0FEOEIsRUFFOUJDLFlBRjhCLEVBRzlCQyxZQUg4QixFQUk5QkMsYUFKOEIsRUFLOUJDLE9BTDhCLEVBVzNCO0FBQUEsYUFLQ0EsT0FBTyxJQUFJLEVBTFo7QUFBQSxtQ0FFREMsaUJBRkM7QUFBQSxNQUVEQSxpQkFGQyxzQ0FFbUJDLFNBRm5CO0FBQUEsa0NBR0RsQixlQUhDO0FBQUEsTUFHREEsZUFIQyxxQ0FHaUJrQixTQUhqQjtBQUFBLGtDQUlEQyxlQUpDO0FBQUEsTUFJREEsZUFKQyxxQ0FJaUJELFNBSmpCOztBQU9ILE1BQUlFLFVBQUo7QUFDQSxNQUFJbkIsU0FBSjs7QUFFQSxNQUFJLE9BQU9ELGVBQVAsS0FBMkIsV0FBL0IsRUFBNEM7QUFDMUNvQixJQUFBQSxVQUFVLEdBQUdWLHVCQUFiO0FBQ0FULElBQUFBLFNBQVMsR0FBR1EsVUFBWjtBQUNELEdBSEQsTUFHTztBQUNMVyxJQUFBQSxVQUFVLEdBQUdwQixlQUFiO0FBQ0FDLElBQUFBLFNBQVMsR0FBR0YsWUFBWSxDQUFDQyxlQUFELENBQXhCO0FBQ0QsR0FoQkUsQ0FrQkg7OztBQUNBLE1BQU1xQixrQkFBa0IsR0FBRztBQUFFRixJQUFBQSxlQUFlLEVBQWZBLGVBQUY7QUFBbUJGLElBQUFBLGlCQUFpQixFQUFqQkE7QUFBbkIsR0FBM0I7QUFDQSxNQUFNSyxpQkFBaUIsR0FBRywyQkFBZVYsV0FBZixFQUE0QkMsWUFBNUIsRUFBMENRLGtCQUExQyxDQUExQjtBQUNBLE1BQU1FLGtCQUFrQixHQUFHLDJCQUFlVCxZQUFmLEVBQTZCQyxhQUE3QixFQUE0Q00sa0JBQTVDLENBQTNCLENBckJHLENBdUJIOztBQUNBLE1BQU1HLFdBQVcsR0FBR0osVUFBVSxDQUFDRSxpQkFBRCxDQUFWLENBQThCQyxrQkFBOUIsQ0FBcEIsQ0F4QkcsQ0EwQkg7O0FBQ0EsTUFBTVosZ0JBQWdCLEdBQUcsNEJBQWdCLENBQWhCLEVBQW1CYSxXQUFuQixFQUFnQ3ZCLFNBQWhDLENBQXpCO0FBRUEsU0FBT1UsZ0JBQVA7QUFDRCxDQXpDTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9yaWVudGF0aW9uTGFiZWxzLCBPcmllbnRhdGlvblJhbmtUeXBlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBkaXN0YW5jZUluUmFuZ2UsIGdldE9yaWVudGF0aW9uIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgT1JJRU5UQVRJT05fUkFOSyB9IGZyb20gJy4uL2NvbnN0JztcblxuLy8gSGVscGVyOiBmaW5kIHRoZSBsb3dlc3QgcmFuayBwb3NzaWJsZVxuY29uc3QgZ2V0UmFua0xpbWl0ID0gKG9yaWVudGF0aW9uUmFuazogT3JpZW50YXRpb25SYW5rVHlwZSk6IG51bWJlciA9PiB7XG4gIGNvbnN0IHJhbmtMaW1pdCA9IE9iamVjdC52YWx1ZXMob3JpZW50YXRpb25SYW5rKS5yZWR1Y2UoKHJhbmtWYWx1ZSwgcmFua09iaikgPT4ge1xuICAgIHJldHVybiBNYXRoLm1heChyYW5rVmFsdWUsIC4uLk9iamVjdC52YWx1ZXMocmFua09iaikpO1xuICB9LCAxKTtcbiAgcmV0dXJuIHJhbmtMaW1pdDtcbn07XG5cbi8vIE1lbW9pemUgdGhlIFJBTktfTElNSVQgZnJvbSBzdGF0aWMgY29uc3QgT1JJRU5UQVRJT05fUkFOS1xuY29uc3QgUkFOS19MSU1JVCA9IGdldFJhbmtMaW1pdChPUklFTlRBVElPTl9SQU5LKTtcblxuLy8gRGlzdGFuY2Ugb2Ygb3JpZW50YXRpb24gcmFuayBiZXR3ZWVuIHRhcmdldCBhbmQgY29tcGFyZS5cbmV4cG9ydCBjb25zdCBvcmllbnRhdGlvbk1hdGNoID0gKFxuICB0YXJnZXRXaWR0aDogbnVtYmVyLFxuICB0YXJnZXRIZWlnaHQ6IG51bWJlcixcbiAgY29tcGFyZVdpZHRoOiBudW1iZXIsXG4gIGNvbXBhcmVIZWlnaHQ6IG51bWJlcixcbiAgb3B0aW9ucz86IHtcbiAgICBvcmllbnRhdGlvbkxhYmVscz86IFBhcnRpYWw8T3JpZW50YXRpb25MYWJlbHM+O1xuICAgIG9yaWVudGF0aW9uUmFuaz86IE9yaWVudGF0aW9uUmFua1R5cGU7XG4gICAgcmFua01heD86IG51bWJlcjtcbiAgICBzcVJhdGlvQWNjdXJhY3k/OiBudW1iZXI7XG4gIH0sXG4pID0+IHtcbiAgY29uc3Qge1xuICAgIG9yaWVudGF0aW9uTGFiZWxzID0gdW5kZWZpbmVkLFxuICAgIG9yaWVudGF0aW9uUmFuayA9IHVuZGVmaW5lZCxcbiAgICBzcVJhdGlvQWNjdXJhY3kgPSB1bmRlZmluZWQsXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCByYW5rTG9va3VwOiBPcmllbnRhdGlvblJhbmtUeXBlO1xuICBsZXQgcmFua0xpbWl0OiBudW1iZXI7XG5cbiAgaWYgKHR5cGVvZiBvcmllbnRhdGlvblJhbmsgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmFua0xvb2t1cCA9IE9SSUVOVEFUSU9OX1JBTks7XG4gICAgcmFua0xpbWl0ID0gUkFOS19MSU1JVDtcbiAgfSBlbHNlIHtcbiAgICByYW5rTG9va3VwID0gb3JpZW50YXRpb25SYW5rO1xuICAgIHJhbmtMaW1pdCA9IGdldFJhbmtMaW1pdChvcmllbnRhdGlvblJhbmspO1xuICB9XG5cbiAgLy8gR2V0IG9yaWVudGF0aW9uIGtleXMgZm9yIHJhbmtpbmcgbG9va3VwIChvcHRpb25zIHBhc3MgdGhyb3VnaClcbiAgY29uc3QgcGFzc1Rocm91Z2hPcHRpb25zID0geyBzcVJhdGlvQWNjdXJhY3ksIG9yaWVudGF0aW9uTGFiZWxzIH07XG4gIGNvbnN0IHRhcmdldE9yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb24odGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgcGFzc1Rocm91Z2hPcHRpb25zKTtcbiAgY29uc3QgY29tcGFyZU9yaWVudGF0aW9uID0gZ2V0T3JpZW50YXRpb24oY29tcGFyZVdpZHRoLCBjb21wYXJlSGVpZ2h0LCBwYXNzVGhyb3VnaE9wdGlvbnMpO1xuXG4gIC8vIEdldCB0aGUgcmFua2luZyBpbmRleCB2YWx1ZSBmcm9tIG9yaWVudGF0aW9uLXRvLW9yaWVudGF0aW9uIGxvb2t1cFxuICBjb25zdCBjb21wYXJlUmFuayA9IHJhbmtMb29rdXBbdGFyZ2V0T3JpZW50YXRpb25dW2NvbXBhcmVPcmllbnRhdGlvbl07XG5cbiAgLy8gRmluZCB0aGUgcGVyY2VudGFnZSBmb3IgY29tcGFyZSByYW5rIGZyb20gMSAoYmVzdCkgdG8gd29yc3QgKHJhbmsgbGltaXQpXG4gIGNvbnN0IG9yaWVudGF0aW9uTWF0Y2ggPSBkaXN0YW5jZUluUmFuZ2UoMSwgY29tcGFyZVJhbmssIHJhbmtMaW1pdCk7XG5cbiAgcmV0dXJuIG9yaWVudGF0aW9uTWF0Y2g7XG59O1xuIl19